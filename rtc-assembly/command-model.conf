subsystem = NFIRAOS
component = rtc

description = NRTC Assembly commands.

receive = [
  {
    name            = init
    description     = """The initialize command restores NRTC software to the state immediately after a boot-up. (engineering)

This command the deactivate the NRTC pipeline, via the pipelineDeactivate command, and will reset all internal states to default values, clear any mode configuration parameters and then request the specified configuration file from the TMT Configuration Service. Upon receiving the configuration file from the TMT configuration service, the NRTC will parse the configuration data and load it into memory. Additionally, by clearing the AO mode, this will stop all pixel reading until the AO mode is (re)set by the mode command.

An equivalent result to this command can be achieved by restarting the NRTC Assembly.

Discussion: There should be a convention to tell the NRTC to use a local version of the configure file(s) for engineering/integration purposes when the TMT configuration service is not yet available. This could be embedded in the configuration name/version.

*Simple Command.*

Precondition:
<ul>
<li> none
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = false
<li> config.name = {input}
<li> config.version = {input}
<li> all other internal parameters set to default values
</ul>"""
    args = [
      {
        name        = configName 
        description = Name of the configuration file to get from the TMT Configuration Service
        type        = string
      }
      {
        name        = configVersion
        description = Version of the configuration file to get from the TMT Configuration Service
        type        = string 
      }
    ]
  }  

  {
    name            = mode
    description     = """The configure command set the AO mode of the NRTC. 

On receiving this command the NRTC will deactivate the NRTC pipeline, via the pipelineDeactivate command and (re)-configure the AO mode of the RTC. This command will also (re-)establishes the private communication with the RPG by creating the mode appropriate connection end-points. Once the AO mode has been configured the RTC will begin to listen to pixels streams and perform pixel calibration for quick-look GUIs, however will not will not be saved or processed further.

The command will also configure which detector input streams will be used for low-order correction. These streams are split into tiers as listed below:
<ul>
<li> Tier 0 (optional)  PWFS providing TT(FA) measurements for acquisition purposes
<li> Tier 1 (required)  single detector that provides LO TTF(A) measurements 
<li> Tier 2 (optional)  1 to 2 detectors that provide LO TT or LO TTF(A) measurements
<li> Tier 3 (optional)  1 to 4 detectors that provide LOT TT measurements
<li> Tier 3F (optional)  single detector that provides LOT focus measurements
</ul>
The restrictions for Tier assignments are given below:
<ul>
<li> Tier 0 can only be the PWFS
<li> Tier 1 must be either the PWFS or a TTF OIWFS
<li> Tier 2 can be the PWFS or any TT/TTF OIWFS or ODGW
<li> Tier 3 can be any OIWFS or ODGW
<li> Tier 3F can only be a TTF OIWFS
<li> a single detector can be assigned to multiple tiers
<li> the same detector cannot be assigned to the same tier twice
<li> the same detector cannot be assigned to both Tier 1 and Tier 2
</ul>

For Tiers 2 and 3, the order in which the detectors are specified defines the order in which the gradients will be assembled for low-order and low-order truth mode reconstruction. If a tier entry is specified as NONE, then that entry is skipped while assembling the low-order gradient vector.

The wavefront corrector rate must be a multiple of the high-order loop rate and the steady-state low-order loop rate. The steady-state low-order loop rate must be a multiple of the steady-state low-order truth loop rate.

Any OIWFS that is assigned to Tier 1 or Tier 3F must be set to TTF mode, while any OIWFS that is assigned to Tier 2 or Tier 3 can be either set to TT or TTF mode. All OIWFSs not assigned to a low-order tier must be set to the NONE mode.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY 
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.mode = true
<li> mode.rateHo = {input rateHo}
<li> mode.rateLo = {input rateLo}
<li> mode.rateLot = {input rateLot}
<li> mode.rateWc = {input rateWc}
<li> mode.tier1 = {input tier1}
<li> mode.tier2[] = {input tier2}
<li> mode.tier3[] = {input tier3}
<li> mode.tier3f = {input tier3f}
<li> lgsState.enable[] = {input lgsEnable}
<li> pwfsState.bin = {input pwfsBin}
<li> oiwfsState.enable[] = {input oiwfs}
<li> if {input lgsEnable[*] == false}, then loop.lgsTt[*] = INACTIVE
<li> if {input tier2[] != ODGW* and input tier3[] != ODGW*}, 
  <ul>
  <li> then odgwState.enable[ODGW*] = false
  <li> else odgwState.enable[ODGW*] = true
  </ul>
<li> if {input tier2[*] == NONE}, then loop.tier2[*] = INACTIVE
<li> if {input tier3[*] == NONE}, then loop.tier3[*] = INACTIVE
<li> if {input tier3f == NONE}, then loop.tier3f = INACTIVE
</ul>"""
    args = [
      {
        name        = lgsEnable
        description = "If an enable flag is true then the RTC will use the corresponding pixel stream for high-order correction. For NGS or SL mode, all LGS WFSs should be disabled. The array is ordered LGS WFS [A B C D E F]."
        type        = array
        dimensions: [6]
        items = {
          type      = boolean
        }
      }
      {
        name        = rateHo
        description = "high-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1
        units       = hertz 
      }
      {
        name        = rateLo
        description = "low-order loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = hertz
      }
      {
        name        = rateLot
        description = "low-order truth loop rate"
        type        = double
        maximum     = 400
        minimum     = 0.1 
        units       = hertz
      }
      {
        name        = rateWc
        description = "wavefront corrector loop rate"
        type        = double
        maximum     = 800
        minimum     = 0.1 
        units       = hertz
      }
      {
        name        = pwfsBin
        description = "width of PWFS bin in pixels" 
        enum        = [ 1, 2, 4, 8, 16 ]
      }
      {
        name        = oiwfs
        description = "OIWFS mode. The array is ordered OIWFS [A B C]" 
        type        = array
        dimensions: [3]
        items = {
          enum      = [ NONE, TT, TTF ]
        }
      }
      {
        name        = tier1
        description = "Tier 1 detector." 
        enum        = [ PWFS, OIWFSA, OIWFSB, OIWFSC ]
      }
      {
        name        = tier2
        description = "Tier 2 detectors. The array is ordered Tier 2 [A B]"
        type        = array
        dimensions: [2]
        items = {
          enum      = [ NONE, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
        }
      }
      {
        name        = tier3
        description = "Tier 3 detectors. The array is ordered Tier 3 [A B C D]"
        type        = array
        dimensions: [4]
        items = {
          enum      = [ NONE, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ] 
        }
      }
      {
        name        = tier3f
        description = "Tier 3F detector."
        enum        = [ NONE, OIWFSA, OIWFSB, OIWFSC ]
      }
      {
        name        = pol
        description = "indicates whether to perform pseudo open-loop (POL) feedback"
        type        = boolean
      }
    ]
    requiredArgs = [ lgsEnable, rateHo, rateLo, rateLot, rateWc, oiwfs, tier1, tier2, tier3, tier3f, pol ] 
  }

  {
    name            = stop
    description     = """This command will open all loops, via the loopOpen command, and abort the processing of an active submit command.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd != UNINITIALIZED
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.lgsBackgroud = false
</ul>"""
  }

  {
    name            = simulate
    description     = """This commands the RTC Pipeline to use alternative simulated connections for sending or receiving data and overrides the default connection points. (engineering)

At least one input parameter must be specified, all unspecified stages will remain unchanged.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> sim.dm0 = {input dm0}
<li> sim.dm11 = {input dm11}
<li> sim.lgs = {input lgs}
<li> sim.lgsf = {input lgsf}
<li> sim.odgw[] = {input odgw}
<li> sim.oiwfs[] = {input oiwfs}
<li> sim.pwfs = {input pwfs}
<li> sim.rpg = {input rpg}
<li> sim.tts = {input tts}
<li> sim.turbulence = {input turbulence}
</ul>"""
    args = [
      {
        name        = dm0 
        description = "Simulated DM0 connection flag."
        type        = boolean
      }
      {
        name        = dm11 
        description = "Simulated DM11 connection flag."
        type        = boolean
      }
      {
        name        = lgs 
        description = "Simulated LGS WFS connections flag."
        type        = boolean
      }
      {
        name        = lgsf 
        description = "Simulated LGSF FSM connections flag."
        type        = boolean
      }
      {
        name        = odgw
        description = "Simulated ODGW connection flag. The array is ordered ODGW [1 2 3 4]."
        type        = array
        dimensions: [4]
        items = {
          type      = boolean
        }
      }
      {
        name        = oiwfs
        description = "Simulated OIWFS connection flag. The array is ordered OIWFS [A B C]."
        type        = array
        dimensions: [3]
        items = {
          type      = boolean
        }
      }
      {
        name        = pwfs 
        description = "Simulated PWFS connection flag."
        type        = boolean
      }
      {
        name        = rpg 
        description = "Simulated RPG connection flag."
        type        = boolean
      }
      {
        name        = tts 
        description = "Simulated TTS connection flag."
        type        = boolean
      }
    ]
  }


 {
    name            = calibLgsBackground
    description     = """This command instructs the NRTC to take new normalized LGS WFS sky & instrument background and/or save the background to the TMT Configuration Service. 

This command applies to all enabled LGS WFSs. If the number of frames to average is specified then the NRTC will average the specified number of frames to measure the current backgrounds. The current detector backgrounds, specified in the configuration file, are subtracted from the measured backgrounds to produce the sky & instrument backgrounds. These sky & instrument backgrounds are then normalized to a 1 second exposure and stored as the current normalized LGS WFS sky & instrument backgrounds in the NRTC, as which point the command returns. Subsequent call to this command will replace the normalized sky & instrument backgrounds and calls to the init command will reset all backgrounds to the defaults specified in the configuration file.

If the sky configuration name input parameter is specified, then the NRTC will save the current normalized sky & instrument backgrounds to the TMT Configuration Service using the configuration name given, after generating a new backgrounds if instructed to do so (i.e. number of frames to average is specified). Note that the configuration file will only contain the normalized sky & instrument backgrounds, and should be different from the configuration name used by the init command.

If neither input argument is specified, then this command will return with an error.

If pixels are not received from all enabled LGS WFSs in a timely manner (TBD), then this command will return with an error and no backgrounds will be updated or saved.

A call to the stop command will abort this process.

Discussion: It is assumed that the lasers will be detuned before executing this command so the sky & instrument backgrounds will include Rayleigh backscattering.

*Discrete Command.*

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
<li> state.lgsBackgroud = true
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.lgsBackgroud = false
<li> if {input skyConfig not specified}, then state.unsavedLgsSky = true
<li> if {input skyConfig is specified}, then state.unsavedLgsSky = false
<li> if {input skyConfig is different from current LGS sky config file}, then state.unsavedConfig = true
</ul>"""
    args = [
      {
        name        = avg
        description = "number of frames to average"
        type        = integer
        minimum     = 0 
      }
      {
        name        = skyConfig
        description = "name of sky configuration file to save the current sky image to in the configuration service."
        type        = string
      }
    ]
  }

  {
    name            = calibModePixel
    description     = """This command sets which raw pixel data are sent directly to the RPG for calibration purposes. 

In CONTINUOUS mode the NRTC will continually stream (averaged) pixel frames to the RPG. The STOP mode will stop pixel frames from being sent to the RPG. The SINGLE mode will only send the next (averaged) pixel frame to the RPG at which point the pixel mode is reset to STOP. In the WC_SYNC mode average process will be delayed by the specified number of pixel frames after a WC override command has been applied. If an additional WC override command is received and applied before this delay has elapsed, then the delay is reset. 

The raw pixel averages value indicates the number of frames that will be averaged before the frame is sent to the RPG.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.pixelAvg[{input detector}] = {input avg}
<li> calibDetector.pixelMode[{input detector}] = {input mode}
<li> calibDetector.pixelDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector pixel calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "raw pixel calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
      {
        name        = avg
        description = "number of pixel frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 1 
      }
      {
        name        = delay
        description = "number of pixel frames to delay (skip) before the starting to average pixel frames, after a WC override command has been applied. This argument must specified only when the mode is set to WC_SYNC. If an additional WC override command is received and applied before this delay time has elapsed, then the delay counter is reset. If a WC override command is not received after the mode is set to WC_SYNC or the WC override commands are disabled, then no averaged pixels will be returned."
        type       = integer
        minimum    = 0
      }
    ]
    requiredArgs = [ detector, mode ] 
  }

 {
    name            = calibModeGrad
    description     = """This command sets which gradients are sent directly to the RPG for calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw pixels, this command operates on gradients, averaging the gradients from the specified detector and then sending that average to the RPG.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibDetector.gradAvg[{input detector}] = {input avg}
<li> calibDetector.gradMode[{input detector}] = {input mode}
<li> calibDetector.gradDelay[{input detector}] = {input delay}
</ul>"""
    args = [
      {
        name        = detector  
        description = "indicates which detector gradient calibration mode to set."
        enum        = [LGSWFS ODGW OIWFS PWFS ALL]
      }
      {
        name        = mode
        description = "gradient calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS, WC_SYNC ]
      }
       {
        name        = avg
        description = "number of gradient frames to average before sending to the RPG. This argument must be specified is the mode is set to SINGLE, CONTINUOUS or WC_SYNC."
        type        = integer
        minimum     = 0 
      }
      {
        name        = delay
        description = "number of gradient frames to delay (skip) before the starting to average gradient frames, after a WC override command has been applied. (see calibModePixel command for more details)."
        type       = integer
        minimum    = 0
      }

    ]
    requiredArgs = [ detector, mode ] 
  }


  {
    name            = calibModeCmd
    description     = """This command sets what averaged DM and TTS commands are sent directly to the RPG. This command is intended for system flat calibration purposes.
 
This command works similarly to calibModePixel command, except instead of operating on raw  pixels, this command operates on DM and TTS commands, averaging the command sent to either the DM and TTS and then sending that average to the RPG.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.avg[{input wc}] = {input avg}
<li> calibWc.mode[{input wc}] = {input mode}
</ul>"""
    args = [
      {
        name        = wc  
        description = "indicates which wavefront corrector command calibration mode to set."
        enum        = [DM0 DM11 TTS ALL]
      }
      {
        name        = mode
        description = "command calibration mode"
        enum        = [ STOP, SINGLE, CONTINUOUS ]
      }
      {
        name        = avg
        description = "number of command frames to average before sending to the RPG. This argument must be specified if the mode is set to SINGLE or CONTINUOUS."
        type        = integer
        minimum     = 0 
      }

    ]
    requiredArgs = [ wc, mode ] 
  }

 {
    name            = calibModeWc
    description     = """This command puts the NRTC wavefront controller into a calibration mode where the DMs and TTS can be adjusted directly by the RPG. 

This command is intended for calibration purposes. While in this calibrate override mode, the DMs and TTS are not updated by their normal path in the NRTC pipeline, but instead they listen for update streams directly from the RPG. While not in calibrate override mode, any WC override command from the RPG is ignored. This command will be rejected if the high or low-order loop is closed.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY 
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> calibWc.override = {input enable}
<li> if {input enable == true}, then calibWc.mode[] = STOP
</ul>"""
    args = [
      {
        name        = enable
        description = "enable or disable override commands from the RPG"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }


  {
    name            = pipelineActivate
    description     = """This command (re-)activate the NRTC pipeline by starting pixel processing, including gradient computation using CoG, and will flattening the DMs, via the dmFlatten command, zero the TTS, via the ttsZero command, zero the LGS FSMs, via the lgsfFsmZero command, and resetting integrators and filters, via the loopParamReset command. 

Subsequent calls to this command will re-activate the pipeline, opening all loops, via the loopOpen command, then resetting parameters and flattening/zeroing controlled elements. This command will also start saving telemetry stream to the RTS and pixel streams to the HOP servers.

Note that published control loop specific telemetry or telemetry sent directly to the RPG will not be started with this command, and will begin once the corresponding loop is closed. 

Discussion: It is anticipated that pixel reading will always occur as long as the NRTC software is running; it is therefore unaffected by this command.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY 
<li> state.mode = true
<li> state.rpgDate = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
<li> lgsState.algo = COG_STATIC | NONE
<li> lgsState.tt = KALMAN
<li> pwfsState.algo = COG_STATIC
<li> odgwState.algo[] = COG_STATIC | NONE
<li> oiwfsState.algo[] = COG_STATIC | NONE
<li> oiwfsState.acqTable[] = false
<li> odgwState.acqTable[] = false
</ul>"""
  }

  {
    name            = pipelineDeactivate
    description     = """This command deactivates the NRTC pipeline, i.e. stopping all closed-loop processing via the loopOpen command, and stopping pixel processing. 

This command is intended to stop the NRTC data processing, i.e. at the end of a night. This command does not stop the RTC pipeline software, instead it leaves the software in a stand-by state whereby the NRTC continues to respond to commands, and the pipeline can easily be reactivated. This command also stops the RTS and HOP servers from saving telemetry and pixel data.

Discussion: It is anticipated that pixel reading will always occur as long as the AO mode is set; it is therefore unaffected by this command. However, any pixels read while in this state are simply calibrated but not stored and will not be processed further.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
<li> calibDetector.pixelMode[] = STOP
<li> calibDetector.gradMode[] = STOP
<li> calibWc.mode[] = STOP
<li> calibWc.override = false
<li> lgsState.algo = NONE
<li> pwfsState.algo = NONE
<li> odgwState.algo[] = NONE
<li> oiwfsState.algo[] = NONE
</ul>"""
  }


  {
    name            = loopOpen
    description     = """This command opens all control loops and offloading in the RTC.

Note that this command does not reset the integrator or filter states; use the pipelineActivate or loopParamReset command to reset those parameters.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.ho = IDLE
<li> loop.lgsFocus = IDLE
<li> loop.lgsDither = NONE
<li> loop.lgsTt[] = IDLE | INACTIVE
<li> loop.lo = IDLE
<li> loop.oiwfsPoa[] = IDLE 
<li> loop.pwfsDither = NONE
<li> loop.pwfsSsm = IDLE
<li> loop.m1Scallop = IDLE
<li> loop.telOffloadTt = IDLE
<li> loop.telOffloadFocus = IDLE
<li> loop.telOffloadMag = IDLE
<li> loop.telOffloadMode = IDLE
<li> loop.twfs = IDLE
<li> loop.tier0 = IDLE
<li> loop.tier1 = IDLE
<li> loop.tier2[] = IDLE | INACTIVE
<li> loop.tier3[] = IDLE | INACTIVE
<li> loop.tier3f = IDLE | INACTIVE
<li> if (lgsState.algo == MF_UPDATE), then lgsState.algo = MF_STATIC
<li> else if (lgsState.algo == MF_COG), then lgsState.algo = COG_STATIC
<li> if (pwfsState.algo == COG_UPDATE), then pwfsState.algo = COG_STATIC
<li> if (oiwfsState.algo == MF_UPDATE), then oiwfsState.algo = MF_STATIC
<li> else if (oiwfsState.algo == MF_COG), then oiwfsState.algo = COG_STATIC
<li> if (odgwState.algo == MF_UPDATE), then odgwState.algo = MF_STATIC
<li> else if (odgwState.algo == MF_COG), then odgwState.algo = COG_STATIC
</ul>"""
  }

  {
    name            = loopLgsFocus
    description     = """This command enables or disables the LGS focus loop, which publishing of the LGS trombone offset (lgsFocus) to control the NCC LGS trombone. 

While the focus error is above LGS focus threshold (from config file) the focus loop state will be ACQUIRE. Once the focus error has dropped below the threshold, the focus loop state will change to LOCK. Note that if the sodium layer estimate, and therefore prepositioning of the LGS trombone, is sufficient, then the initial focus should be below the threshold, and focus loop will be locked immediately. If the LGS focus loop is not IDLE, an enable request will be a no-op.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable} = true, then loop.lgsFocus != IDLE
<li> if {input enable} = false, then loop.lgsFocus = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the LGS focus loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLgsTt
    description     = """This command enables or disables the LGS TT loop that sends commands to the LGSF to control LGSF FSMs. 

When the loop is set to OPEN, TT correction commands to the LGSF are not updated and LGS TT loop is halted. However Kalman filter and integrator outputs are not reset, such that if FSM will remain at their current position (however the internal Kalman filter states are reset); these outputs can be reset via the loopParamReset command. When the loop is set to CLOSE, the LGS TT loop is active and a TT drift terms are added to measured TT errors. When the loop is set to CLOSE_WO_DRIFT, the LGS TT loop is active but TT drift terms are ignored. 

While the LGS TT error is above the LGS FSM TT threshold (from config file), the FSM TT loop state will be ACQUIRE. Once the TT error has dropped below the threshold the FSM TT loop state will change to LOCK. If the LGS TT loop is not IDLE, an enable request will be a no-op.

The control command will only be applied to the LGSF FSM corresponding to the enabled LGS WFSs (lgsState.enable[]). LGSF FSMs corresponding to disabled LGS WFSs will remain in the IDLE state and will be sent zeros.

Discussion: The acquisition of LGS TT may only take a few frames for the FSMs to move to the correct positions and start guiding. 

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input loop} = OPEN, then
  <ul> 
  <li> loop.lgsTt[] = IDLE | INACTIVE
  <li> loop.lgsDriftTt = false
  </ul>
<li> if {input loop} = CLOSE, then
  <ul> 
  <li> loop.lgsTt[] != IDLE
  <li> loop.lgsDriftTt = true
  </ul>
<li> if {input loop} = CLOSE_WO_DRIFT, then
  <ul> 
  <li> loop.lgsTt[] != IDLE
  <li> loop.lgsDriftTt = false
  </ul>
</ul>"""
    args = [
      {
        name        = loop  
        description = "indicates desired state of the LGS TT loop"
        enum        = [ OPEN, CLOSE, CLOSE_WO_DRIFT ]
      }
    ]
    requiredArgs = [ loop ] 
  }



 {
    name            = setLgsTtCntrl
    description     = """This command sets the controller type used in the LGS TT loop.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
<li> loop.lgsTt[] = IDLE | INACTIVE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> lgsState.tt = {input cntrl}
</ul>"""
    args = [
      {
        name        = cntrl  
        description = "desired LGSF FSM TT controller"
        enum        = [ INTEGRATOR, KALMAN ]
      }
    ]
    requiredArgs = [ cntrl ] 
  }

  {
    name            = loopTwfs
    description     = """This command enables or disables the TWFS loop which updates the LGS WFS TWFS/MFU reference vector based on PWFS measurements. 

If enabled, the TWFS portion of the TWFS/MFU reference vector is updated based on PWFS measurements. If the TWFS loop is not IDLE, an enable request will be a no-op. Note that the MFU portion of the TWFS/MFU reference vector is updated independently, which is enabled when LGS MF are being built/updated (lgsState.algo = MF_COG | MF_UPDATE). 

Disabling the TWFS loop does not reset the TWFS/MFU reference vector stored in the internal integrator, it merely stops any further TWFS updates from PWFS measurements. To reset the TWFS/MFU reference vector use the command loopParamReset. 

Disabling the TWFS reference vector merely stops the update to the TWFS reference vector and does not impact any other PWFS operation.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.twfs != IDLE
<li> if {input !enable}, then loop.twfs = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the TWFS loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopHigh
    description     = """This command enables or disables the high-order loop which applies the high-order correction errors to the control path. 

While waiting for the loop to stabilize, the high-order loop state will be set to ACQUIRE. Once the loop has stabilized, the high-order loop state will be set to LOCK. If the high-order loop is not IDLE, an enable request will be a no-op.

Disabling the high-order loop does not reset the correction vector stored in the main integrator; it merely stops the high-order error vector. To reset the main integrator use the command loopParamReset. Note that disabling the high-order correction does not interfere with the low-order path.

Discussion: The method we use to determine when the high-order loop is stabilized is TBD. This may entail ramping up the high-order path gain over several frames.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.ho != IDLE
<li> if {input !enable}, then loop.ho = IDLE
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the high-order loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier0
    description     = """This command enables or disables Tier 0, the low-order loop using the PWFS to control TT and focus. 

This command is intended to be used as an optional first step in low-order acquisition.

If the Tier 1 and/or Tier 2 loops are already closed, or is acquiring, this command cannot be executed and will return an error. If either Tier 1 or 2 loops are closed while Tier 0 is active, then a TBD hand-off procedure is triggered and the Tier 0 loop will be opened.

Disabling the Tier 0 loop merely stops the PWFS update of low-order loop and does not impact any other PWFS operation.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.tier1 = IDLE
<li> loop.tier2[] = IDLE | INACTIVE
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier0 != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.lo = IDLE
  <li> loop.tier0 = IDLE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 0 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }


  {
    name            = acqTableSet
    description     = """This command sets the guiding acquisition and dithering acquisition tables used by the OIWFSs and ODGWs.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.lo = IDLE
<li> oiwfsState.enable[{input detector}] = true
<li> odgwState.enable[{input detector}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> oiwfsState.acqTable[{input detector}] = true
<li> odgwState.acqTable[{input detector}] = true
</ul>"""
  args = [
      {
        name        = detector
        description = "indicates which detector the acquisition and dither tables are for."
        enum        = [ OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
      }
      {
        name        = guideTable
        description = """OIWFS/ODGW guiding acquisition table. The table will have the following columns:
  <ul>
  <li> step number
  <li> window size
  <li> frame rate
  <li> TBD detector parameters, e.g. exposure time, number of co-adds, ...
  <li> signal gain (the value corresponding to the locked row in the table is nominally 1)
  <li> next step number in the current table
  <li> corresponding step in the companion table, e.g. if the table is a guiding table then this column identifies the corresponding step number in the dither table, and vice versa
  <li> step label (TBC)
  </ul>


It is TBD how this table will be serialized and how to represent that data structure in the Interface Database.
"""
        type        = string
      }
      {
        name        = ditherTable
        description = """OIWFS/ODGW dithering acquisition table. This table will have the same format as the guiding acquisition table described in the guideTable argument."""
        type        = string
      }
    ]
    requiredArgs = [ detector, guideTable, ditherTable ] 
  }

  {
    name            = loopLowTier1
    description     = """This command enables or disables the low-order loop which applies low-order correction errors to the control path from the Tier 1 detector, i.e. the LO TTF detector. 

Enabling this loop triggers the Tier 1 acquisition process that steps through the Tier 1 acquisition table. While stepping through this table, the Tier 1 loop state is set to ACQUIRE. Once the acquisition process is complete the state is set to LOCK.

If the Tier 0 loop is closed, then a TBD hands-off procedure is performed to transition TTF control from the PWFS to the Tier 1 detector. If the PWFS is the Tier 1 detector, then this hands-off procedure is a no-op. 

If enabled, and the Tier 1 detector is already acquiring or locked, this command is a no-op. Additionally, if the Tier 1 detector is the PWFS then the ACQUIRE state is skipped since the PWFS does not have an acquisition procedure. If the PWFS is configured as the Tier 1 detector, disabling Tier 1 merely stops the PWFS control in the low-order path and does not impact any other PWFS operation.

Disabling Tier 1 will also disable Tier 3. 

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
<li> if {loop.tier1 == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier0 = IDLE
  <li> loop.tier1 != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.tier1 = IDLE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 1 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier2
    description     = """This command enables or disables the low-order loop which apples low-order correction errors to the control path from the Tier 2 detectors, i.e. the LO TT/TTF detectors. 

Enabling this loop triggers the Tier 2 acquisition process that steps through the Tier 2 acquisition tables. While stepping through these tables, the Tier 2 loop is set to ACQUIRE. Once the acquisition process is complete the state is set to LOCK. 

If enabling the Tier 2 loop but the detector is inactive (mode.tier2[] = NONE), then that detector is skipped and the corresponding Tier 2 state will be INACTIVE. If a Tier 2 detector is already acquiring or locked, this command is a no-op for that detector and will proceed to the next Tier 2 detector.

If the Tier 0 loop is closed, then a TBD hands-off procedure is performed to transition TT/TTF control from the PWFS to the Tier 2 detector(s). If the PWFS is the Tier 2 detector, then this hands-off procedure is a no-op and will proceed to the next Tier 2 detector. If PWFS in configured as a Tier 2 detector then disabling Tier 2 merely stops the PWFS control in the low-order path, and does not impact any other PWFS operation.

Disabling Tier 2 will also disable Tier 3.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> calibWc.override = false
<li> if {loop.tier2[] == ODGW*}, then odgwState.acqTable[ODGW*] = true
<li> if {loop.tier2[] == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> if {at least one mode.tier2[] != NONE}, then loop.lo != IDLE
  <li> loop.tier0 = IDLE
  <li> loop.tier2[] != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.tier2[] = IDLE | INACTIVE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 1 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLowTier3
    description     = """This command enables or disables the low-order loop which applies low-order correction errors to the control path from the Tier 3 and Tier 3F detectors, i.e., the LOT detectors. 

Enabling this loop triggers the Tier 3 and Tier 3F acquisition process that steps through the acquisition tables. While stepping through these tables, the Tier 3 loop state is set to ACQUIRE. Once the acquisition process has been completed the state is set to LOCK. 

Tier 3 can only be closed after Tier 1 and all active Tier 2 loops have been started, however Tier 3 acquisition will not start until after Tier 1 & 2 detectors have completed their acquisition (loop.tier1 = LOCK and loop.tier2[] = LOCK | INACTIVE). Therefore, if there are no active Tier 2 detectors, only Tier 1 must be acquired before closing Tier 3 loops.

If enabling is requested and a Tier 3 or 3F detector is inactive (mode.tier3[] = NONE or mode.tier3f = NONE), that detector is skipped and the corresponding Tier state will be INACTIVE. If a Tier 3 detector is already acquiring or locked, this command is a no-op for that senor and will proceed to the next Tier 3 detector.

Enabling the Tier 3 loo will set the LO path filter to a high-pass filter, and the LOT path filter to a low-pass filter. Conversely, disabling Tier 3 will set the low-order mode filter to an all-pass filter, and the low-order truth filter to be an all-stop filter.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.tier1 != IDLE
<li> loop.tier2[] != IDLE
<li> calibWc.override = false
<li> if {loop.tier3[] == ODGW*}, then odgwState.acqTable[ODGW*] = true
<li> if {loop.tier3[] == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
<li> if {loop.tier3f == OIWFS*}, then oiwfsState.acqTable[OIWFS*] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier3[] != IDLE
  <li> loop.tier3f != IDLE
  </ul>
<li> if {input !enable}, then 
  <ul>
  <li> loop.lo != IDLE
  <li> loop.tier3[] = IDLE | INACTIVE
  <li> loop.tier3f = IDLE | INACTIVE
  </ul>
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the Tier 3 loop"
        type        = boolean
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopLgsDither
    description     = """This command enables or disables LGS dithering. 

If non-common path (NCP) dithering is selected, then the NRTC assumes that LGSF has, or will, be instructed to dither the LGS FSMs. The NRTC will then listen to the LGS FSM sensed positions stream from the LGSF and estimate the dither signal for optimization and removal from the LGS WFS gradients. If the LGS TT loop is open (loop.lgsTt[] == IDLE) then the RTC will send the current LGSF FSM command, as stored in the FSM integrator or Kalman filter to trigger the LGSF FSM sensed position response.

If common path (CP) dithering is selected, then the CP LGS dither signal (tip/tilt) is applied to DM0. The CP dither signal is applied to the actuator commands sent to the DM. If the High and Low-Order loops are stopped (loop.ho = IDLE and loop.lo = IDLE) before or during the application of the CP LGS dither signal, the dither signal is superimposed on the current DM0 shape, as stored in the main wavefront corrector integrator. This dither signal is completely independent of the PWFS dither signal described in the loopPwfsDither command.

If NONE is selected, then the NRTC will not dither DM0 and ignore the dither signal applied to the LGSF FSMs. If the LGS WFS gradient optimization algorithm is set to matched filter optimization (lgsState.algo == MF_COG | MF_UPDATE) and the dithering is disabled, then the LGS WFS gradient optimization is halted (lgsState.algo == COG_STATIC | MF_STATIC).

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.lgsDither = {input enable}
<li> if {input enable == NONE and lgsState.algo == MF_COG | MF_UPDATE}, then lgsState.algo = COG_STATIC | MF_STATIC
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the LGS Dithering loop"
        enum        = [ CP, NCP, NONE ]
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = loopPwfsDither
    description     = """This command enables or disables PWFS dithering. 

If non-common path (NCP) dithering is selected, then the NRTC assumes that NCC has, or will, be instructed to dither the VNW FSM. The NRTC will then listen to the VNW FSM sensed position stream from the NCC and estimate the dither signal for optimization and removal from the PWFS gradients. 

If common path (CP) dithering is selected, then the CP PWFS dither signal is applied to DM0. The CP dither signal is applied to the actuator commands sent to the DM. If the High and Low-Order loops are stopped (loop.ho=IDLE & loop.lo=IDLE) before or during the application of the CP dither signal, the dither signal is superimposed on the current DM0 shape, as stored in the main wavefront corrector integrator. This dither signal is completely independent of the LGS dither signal described in the loopLgsDither command.

If NONE is selected, then the NRTC will not dither DM0 and will ignore the VNW FSM position stream. If the PWFS gradient optimization algorithm is set to optical gain optimization (pwfsState.algo == COG_UPDATE) and the dithering is disabled, then the PWFS gradient optimization is halted (pwfsState.algo == COG_STATIC).

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> loop.pwfsDither = {input enable}
<li> if {input enable == NONE and pwfsState.algo == COG_UPDATE}, then pwfsState.algo = COG_STATIC
</ul>"""
    args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the PWFS Dithering loop"
        enum        = [ CP, NCP, NONE ]
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = algoSetLgs
    description     = """This command sets the LGS gradient computation algorithm.

When the LGS algorithm is set to MF_UPDATE, the LGS matched filter optimization is started. This algorithm can only be selected if LGS dithering is enabled (loop.lgsDither != NONE). If the previous algorithm was not MF_STATIC, then the LGS pixel processing does not have a set of matched filters, therefore it will initially use CoG (lgsState.algo = MF_COG) and once a set of matched filters has been computed then they will be applied to the pixel processing (lgsState.algo = MF_UPDATE). 

While matched filter optimization is enabled (lgsState.algo = MF_COG | MF_UPDATE) the  LGS dither DLL integrators, i<sub>0</sub> frames and matched filters will be updated. While not optimizing (lgsState.algo != MF_COG | MF_UPDATE) the updating of optimization parameters will be suspended. Re-enabling the optimization will append new data to the previously gathered statistics; however RTC will delay the new statistic gathering so the new data lines up in dither signal phase with where the old data left off. 

Enabling matched filter optimization will also trigger the updating of the MFU portion of the TWFS/MFU reference vector. However while the telescope is preforming a dither, the RTC should be instructed by the AOSQ suspend the matched filter optimization by switching to MF_STATIC or COG_STATIC.

When the LGS algorithm is set to COG_STATIC, the LGS gradients will be generated using center of gravity. Any matched filter statistic gathering will be suspended, but not reset. This is the default state after activating the pipeline, via the pipelineActivate command.

When the LGS algorithm is set to MF_STATIC, the LGS gradients will be generated using the current matched filters however will not updated the current matched filters. Matched filter statistic gathering will be suspended, but not reset. This algorithm can only be selected if the previous state was MF_UPDATE.

When the LGS algorithm is set to CUSTOM, the TBD...

Note that this command does not reset the  LGS dither DLL integrators, time-series of i<sub>b</sub> frames used to update the i<sub>0</sub> frame or matched filters. To reset the LGS optimization parameters the loopParamRest command can be used.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> lgsState.enable[{at least one}] = true
<li> if {input enable == MF_UPDATE}, then loop.lgsDither != NONE
<li> if {input enable == MF_STATIC}, then lgsState.algo = MF_UPDATE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> lgsState.algo = {input algo} | MF_COG
</ul>"""
    args = [
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, MF_UPDATE, MF_STATIC, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }

 {
    name            = algoSetPwfs
    description     = """This command sets the PWFS gradient computation algorithm.

When the PWFS algorithm is set to COG_UPDATE, the PWFS optical gain optimization is started. This algorithm can only be selected if PWFS dithering is enabled (loop.pwsfDither != NONE). However while the telescope is preforming a dither, the RTC should be instructed by the AOSQ halt optical gain optimization by switching to COG_STATIC.

While optical gain optimization is enabled (pwfsState.algo = COG_UPDATE) the PWFS optical gain value and NCP dither DLL integrator will be updated. While not optimizing (pwfsState.algo != COG_UPDATE) the updating of optimization parameters will be suspended. Re-enabling the optimization will append new data to the previously gathered statistics; however RTC will delay the new statistic gathering so the new data lines up in dither signal phase with where the old data left off. 

When the PWFS algorithm is set to COG_STATIC, the PWFS gradients will be generated using center of gravity. This is the default state after activating the pipeline, via the pipelineActivate command.

When the PWFS algorithm is set to CUSTOM, then TBD...

Note that this command does not reset the PWFS optical gain value or the NCP dither DLL integrator. To reset the optical gain the loopParamRest command can be used.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> if {input enable == COG_UPDATE}, then loop.pwfsDither != NONE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> pwfsState.algo[] = {input algo}
</ul>"""
    args = [
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, COG_UPDATE, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }

 {
    name            = algoSetOiwfsOdgw
    description     = """This command sets the OIWFS/ODGW gradient computation algorithm.

When the OIWFS/ODGW algorithm is set to MF_UPDATE, the OIWFS/ODGW matched filter optimization is started. If the previous algorithm was not MF_STATIC, then the OIWFS/ODGW pixel processing does not have a matched filter, therefore it will initially use CoG (oiwfs/odgwState.algo = MF_COG) and once the matched filter has been computed then it will be applied to the pixel processing (oiwfs/odgwState.algo = MF_UPDATE). However while the telescope is preforming a dither or the detector is (re-)acquiring, the RTC should be instructed by the AOSQ halt the matched filter optimization by switching to MF_STATIC or COG_STATIC.

When the OIWFS/ODGW algorithm is set to BP, the OIWFS/ODGW gradients will be generated using the brightest pixel. 

When the OIWFS/ODGW algorithm is set to COG_STATIC, the OIWFS/ODGW gradients will be generated using center of gravity (CoG).

When the OIWFS/ODGW algorithm is set to MF_STATIC, the OIWFS/ODGW gradients will be generated using the current matched filters however will not updated the current matched filters. This algorithm can only be selected if the previous state was MF_UPDATE.

When the OIWFS/ODGW algorithm is set to CUSTOM, the TBD...

Note that this command does not clear the current OIWFS/ODGW matched filters.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> oiwfsState.enable[{input detector}] != NONE 
<li> odgwState.enable[{input detector}] = true
<li> if {input algo == MF_STATIC}, then 
  <ul>
  <li> oiwfsState.algo[{input detector}] = MF_UPDATE
  <li> odgwState.algo[{input detector}] = MF_UPDATE
  </ul>
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> oiwfsState.algo[{input detector}] = {input algo} | MF_COG 
<li> odgwState.algo[{input detector}] = {input algo} | MF_COG 
</ul>"""
    args = [
      {
        name        = detector  
        description = ""
        enum        = [ OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
      }
      {
        name        = algo  
        description = ""
        enum        = [ COG_STATIC, MF_UPDATE, MF_STATIC, BP, CUSTOM ]
      }
    ]
    requiredArgs = [ algo ] 
  }


 {
    name            = offloadOiwfsPoa
    description     = """This command enables or disables offloading to the OIWFS POAs. 

Normally POA offload will only be activated for OIWFSs in Tier 1 and 2, however to facilitate calibration procedures. The POA offloading can be enabled whenever the corresponding OIWFS is sending pixels to the RTC. 

If enabled, and the OIWFSs have not acquired their guide stars, the acquisition process is started. If the guide stars are already acquired, or are acquiring, as a result of Tiers 1 or 2 being enabled, then the acquisition process is allowed to complete.

When an OIWFS POA offloading is enabled the NRTC will publish the corresponding POA offloading parameter (oiwfsAPoa, oiwfsBPoa, or oiwfsCPoa). Whenever the offloading state (loop.oiwfsPoa[]) transitions into the ACTIVE state, the corresponding LPF will be reset. 

Disabling the POA offloading merely stops any offloading sent to the POA, and does not impact any other OIWFS operation.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.oiwfsPoa[] != IDLE
<li> if {input !enable}, then loop.oiwfsPoa[] = IDLE 
</ul>"""
  args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the OIWFS POA offloading loop. The array is ordered OIWFS [A B C]"
        type        = array
        dimensions: [3]
        items       = {
          type      = boolean
        }
      }
      {
        name        = time
        description = "timestamp indicating when the offload stage should change"
        type        = double
        units       = tai
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = offloadPwfsSsm
    description     = """This command enables or disables PWFS offloading to the NCC SSM.

When enabled the NRTC will publish the SSM offloading parameter (pwfsTtf).

Disabling the PWFS SSM offloading merely stops any offloading sent to the SSM, and does not impact any other PWFS operation.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input enable}, then loop.pwfsSsm != IDLE
<li> if {input !enable}, then loop.pwfsSsm = IDLE
</ul>"""
  args = [
      {
        name        = enable  
        description = "indicates whether to enable or disable the PWFS SSM offloading loop"
        type        = boolean
      }
      {
        name        = time
        description = "timestamp indicating when the offload stage should change"
        type        = double
        units       = tai
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = offloadTcs
    description     = """This command enables or disables offloading to the TCS.

When enabled the NRTC will publish various modes for the TCS (m1Scallop, telOffloadTt, telOffloadFocus, telOffloadMag, and/or telOffloadMode). 
 
Disabling the TCS offloading merely stops any offloading sent to the TCS, and does not impact any other pipeline operation.

At least one input argument must be specified.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input m1Scallop} 
  <ul>
  <li> then loop.m1Scallop != IDLE
  <li> else loop.m1Scallop = IDLE
  </ul>
<li> if {input telOffloadTt} 
  <ul>
  <li> then loop.telOffloadTt != IDLE
  <li> else loop.telOffloadTt = IDLE
  </ul>
<li> if {input telOffloadFocus} 
  <ul>
  <li> then loop.telOffloadFocus != IDLE
  <li> else loop.telOffloadFocus = IDLE
  </ul>
<li> if {input telOffloadMag} 
  <ul>
  <li> then loop.telOffloadMag != IDLE
  <li> else loop.telOffloadMag = IDLE
  </ul>
<li> if {input telOffloadMode} 
  <ul>
  <li> then loop.telOffloadMode != IDLE
  <li> else loop.telOffloadMode = IDLE
  </ul>
</ul>"""
  args = [
      {
        name        = m1Scallop
        description = "indicates whether to enable or disable the M1 scalloping"
        type        = boolean
      }
      {
        name        = telOffloadTt 
        description = "indicates whether to enable or disable the TT telescope offloading"
        type        = boolean
      }
      {
        name        = telOffloadFocus  
        description = "indicates whether to enable or disable the focus telescope offloading"
        type        = boolean
      }
      {
        name        = telOffloadMag 
        description = "indicates whether to enable or disable the magnification telescope offloading"
        type        = boolean
      }
      {
        name        = telOffloadMode  
        description = "indicates whether to enable or disable the telescope mode offloading"
        type        = boolean
      }
    ]
  }

  {
    name            = pwfsTelDither
    description     = """This command sets or clear the flag indicating that the telescope is performing a dither. 

While the telescope is dithering, the PWFS gradients will be scaled by a &le;1 gain. When the telescope is not dithering the gradient gain will be unity.

The gain input can only be specified when the dither input is set to true, otherwise the command will be rejected.

If the gain input is not specified, then the PWFS telescope dither gradient gain from the NRTC configuration file is used, otherwise the specified value is used instead of the value from the configuration file. 

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> pwfsState.telDitherFlag = {input dither} 
<li> if {input gain is specified}, 
  <ul>
  <li> then pwfsState.telDitherGain = {input gain}
  <li> else pwfsState.telDitherGain = {gain from config file}
  </ul>
<li>
</ul>"""
  args = [
      {
        name        = dither  
        description = "indicates whether the telescope is dithering or not"
        type        = boolean
      }
      {
        name        = gain  
        description = "gain applied to the PWFS gradients while the telescope is performing a dither"
        type        = double
      }
      {
        name        = time
        description = "timestamp indicating when the specified dither flag takes effect"
        type        = double
        units       = tai
      }
    ]
    requiredArgs = [ dither ] 
  }

  {
    name            = guideStarHandOff
    description     = """This command disables or (re-)enables the PWFS or a OIWFS or a ODGW a guide star for a hand-off procedure for during non-sidereal tracking.

When disabled the NRTC temporarily ignore the detector stream, treating it as a loss of measurement, without raising alarms. When (re-)enabled the NRTC will attempt to acquire the guide star following the standard procedure.    

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> oiwfsState.enable[{input detector}] != NONE 
<li> odgwState.enable[{input detector}] = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> if {input detector == PWFS} then pwfsState.handOff = {input disable} 
<li> oiwfsState.handOff[{input detector}] = {input disable} 
<li> odgwState.handOff[{input detector}] = {input disable}
</ul>"""
  args = [
      {
        name        = detector  
        description = ""
        enum        = [ PWFS, OIWFSA, OIWFSB, OIWFSC, ODGW1, ODGW2, ODGW3, ODGW4 ]
      }
      {
        name        = disable  
        description = "indicates whether to disable or (re-)enable the detector for guide star hand-off"
        type        = boolean
      }
    ]
    requiredArgs = [ detector, disable ] 
  }

  {
    name            = loopParamReset
    description     = """This command will reset one or more loop parameters. (calibration)

If only a parameter name prefix is specified, any parameter with the matching name prefix will be reset. The list of all possible loop parameters that can be reset by this command are: 
<ul>
<li> <b> wc_int </b> - wavefront corrector integrator (= 0)
<li> <b> wc_tt_lpf </b> - TTS filter states (= 0)
<li> <b> wc_tel_lpf	</b> - Telescope offload  high-pass filter states (= 0)
<li> <b> ho_m1Scallop_lpf </b> - M1 Scalloping  high-pass filter states (= 0)
<li> <b> ho_psd </b> - High-order PSD & WFE (discard gathered statistics)
<li> <b> ho_turb </b> - Slodar & other turbulence parameters (discard gathered statistics)
<li> <b> lo_kalman_output </b> - low-order Kalman filter output (= 0)
<li> <b> lo_kalman_avg </b> - low-order Kalman filter mode average feedback (= 0)
<li> <b> lo_mode_hpf </b> - low-order (Tier 1 & 2) high-pass filter states (= 0)
<li> <b> lo_mode_lpf </b> - low-order truth (Tier 3 & 3F) low-pass filter states (= 0)
<li> <b> lo_poaA_lpf </b> - OIWFS A POA offload low-pass filter state (= 0)
<li> <b> lo_poaB_lpf </b> - OIWFS B POA offload low-pass filter state (= 0)
<li> <b> lo_poaC_lpf </b> - OIWFS C POA offload low-pass filter state (= 0)
<li> <b> lo_ssm_lpf </b> - PWFS SSM offload low-pass filter state (= 0)
<li> <b> lo_psd </b> - Low-order PSD & WFE (discard gathered statistics)
<li> <b> pwfs_opt_dll </b> - PWFS NCP dither DLL integrator and phase estimate (= 0)
<li> <b> pwfs_opt_gain </b> - PWFS optical gain (pwfsState.opticalGain = 1)
<li> <b> lgs_focus_lpf </b> - LGS focus low-pass filter states (= 0)
<li> <b> lgs_opt_dll </b> - LGS dither DLL integrators and phase estimates (= 0)
<li> <b> lgs_opt_mf </b> - LGS matched filters, if lgsState.algo == MF_UPDATE then lgsState.algo = MF_COG
<li> <b> lgs_opt_i0 </b> - LGS i<sub>0</sub> (discard gathered statistics, i.e. time-series of i<sub>b</sub> frames)
<li> <b> lgs_tt_int </b> - LGSF FSM integrator (= 0)
<li> <b> lgs_tt_kalman </b> - LGSF FSM Kalman filter output (= 0)
<li> <b> lgs_tt_psd </b> - LGS TT PSD (discard gathered statistics)
<li> <b> lgs_twfs_int </b>	- TWFS/MFU reference vector integrator (= 0)
</ul>

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = enable  
        description = "Name or name prefix of the loop parameter to reset. Passing an empty string will reset all loop parameters."
        type        = string
      }
    ]
    requiredArgs = [ enable ] 
  }

  {
    name            = paramConfigSave
    description     = """This command tells the NRTC to save the current parameter configuration to the TMT configuration service using the specified parameter configuration name. (calibration)

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.unsavedConfig = false
</ul>"""
  args = [
       {
        name        = config 
        description = Name of the configuration file to save the current parameters to.
        type        = string
      }
    ]
    requiredArgs = [ config ] 
  }

  {
    name            = paramConfigSet
    description     = """This command tells the NRTC to set the value of any configuration parameter, i.e. a parameter that is specified in the parameter configuration file. (calibration)

The valid parameters for this command are TBD. This command is intended for constructing a new parameter configuration file as well as for engineering and debugging purposes. The NRTC will update the specified parameter, either by value or loading a file that contains the new value. The file format is dependent on the parameter specified and is TBD. Note the new parameter is not automatically saved to the configuration service and will be lost if the init command is called. To signal this condition, the unsaved parameter flag is set. To save the current configuration, use the paramConfigSave command.

Exactly one of the value or file arguments must be specified. Consequently the required argument will be set based on the parameter identifier (i.e. smaller parameters must use value while larger parameters must use file). The details for this command are TBD.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
<li> state.unsavedConfig = true
</ul>"""
  args = [
       {
        name        = param 
        description = Configuration parameter identifier 
        type        = string
      }
      {
        name        = value 
        description = New value for the  specified parameter as a string
        type        = string
      }
      {
        name        = file 
        description = Full path to the file that contains the new data for the specified parameter 
        type        = string
      }
    ]
    requiredArgs = [ file ] 
  }

  {
    name            = lgsfFsmZero
    description     = """This command sends a zero command to all LGSF FSMs. 

This command is rejected if the LGS TT loop is closed. 

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.lgsTt[] = IDLE | INACTIVE
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = dmFlatten
    description     = """This command sends a system flat or mirror flat command to a DM.

A SYSTEM input corresponds to sending the system flat, as specified by the RPG, will be sent to the DM. A MIRROR input corresponds to sending a zero command to the DM, while a VIRGINIZE input means a decaying sinusoid is applied to the DM, result in a flat mirror. A NONE input means the DM will not be moved. This command is rejected if either the high- or low-order loops are closed, or if the DMs are in the override calibration mode.

If both inputs are set to NONE, then this command is no-op and will return a warning.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = dm0
        description = "flatten DM0"
        enum        = [ SYSTEM, MIRROR, VIRGINIZE, NONE ] 
      }
      {
        name        = dm11
        description = "flatten DM11"
        enum        = [ SYSTEM, MIRROR, VIRGINIZE, NONE ] 
      }
    ]
    requiredArgs = [ dm0, dm11 ] 
  }

  {
    name            = ttsZero
    description     = """This command sends a system zero or mirror zero command to the TTS. 

A MIRROR input corresponds to sending a raw zero command to the TTS, meaning the stage is zeroed with respect to physical unit rotation relative to its mount. A SYSTEM input means the system zero position, as specified by the configuration file, will be sent to the TTS, corresponding the position of TTS that nominally aligns the system. This command is rejected if either the high- or low-order loops are closed, or if the TTS is in the override calibration mode.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = true
<li> loop.ho = IDLE
<li> loop.lo = IDLE
<li> calibWc.override = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = tts
        description = "TTS zero command"
        enum        = [ SYSTEM, MIRROR ] 
      }
    ]
    requiredArgs = [ tts ] 
  }

  {
    name            = rtsDelete
    description     = """This command deletes data stored on the RTS, including PSFR data and nightly telemetry.

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = psfr
        description = "Delete all PSFR data that is older then the specified number of hours. A value of zero will delete all PSFR data (TBC)"
        type        = integer 
        units       = hour
      }
      {
        name        = telem
        description = "Delete all nightly telemetry data that is older then the specified number of hours. A value of zero will delete all nightly telemetry data (TBC)"
        type        = integer 
        units       = hour
      }
       {
        name        = tag
        description = "Delete tagged data stored on the RTS (TBC)"
        type        = string 
        units       = NoUnits
      }

    ]
  }

  {
    name            = rtsQuery 
    description     = """This command queries RTC for specific data. (engineering)

It is expected that this command will return a URL link to the required data, pointing to a webserver running on the RTS.

This command is TBD.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }


  {
    name            = rtsSave 
    description     = """This command saves specific data as tagged data either saved on the RTS or pushed to the DMS. (engineering)

The interface to this command is TBD.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
 args = [
      {
        name        = name 
        description = Name of diagnostic or telemetry data to save (TBD)
        type        = string
      }
      {
        name        = time 
        description = "timestamp range of data to save. Arrays is ordered [startTime endTime]"
        type        = array
        dimensions: [2]
        items = {
          type      = double
        }
        units         = tai
      }
      {
        name        = dest 
        description = Destination of tagged data
        enum        = [ RTS, DMS ]
      }

    ]
    requiredArgs = [ name, time, dest ] 

  }

  {
    name            = test
    description     = """This command runs the automatic diagnostic self-test sequence. (engineering)

The details of the command are TBD.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  }

  {
    name            = bufferDump
    description     = """This command dumps the values currently in the circular buffers to the local hard drives. (engineering)

The NRTC pipeline must be deactivated, via the pipelineDeactivate command, prior to calling this command, to prevent the circular buffers from being modified during the write process.

By default the data is only saved locally on the NRTC machines. However, this command can optionally push copies of the circular buffers to the Real-time Telemetry Storage (RTS) server.

*Simple Command.*

Precondition:
<ul>
<li> state.cmd = READY
<li> loop.ready = false
</ul>
Execution:
<ul>
<li> state.cmd = BUSY
</ul>
At Completion:
<ul>
<li> state.cmd = READY
</ul>"""
  args = [
      {
        name        = prefix 
        description = "File name prefix. The path and post-fix of the file is determined by the RTC servers and is TBD."
        type        = string
      }
      {
        name        = rts 
        description = "A flag indicating if the buffer data should also be tagged and saved to the RTS for more permanent storage."
        type        = boolean
      }
    ]
    requiredArgs = [ prefix, rts ] 
  }



]


